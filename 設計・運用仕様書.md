## **監視者アーキテクチャ 設計・運用仕様書 Ver.1.0**

### 1. 概要と目的

本仕様書は、この戦闘支援ツールの根幹をなす**状態管理および処理フローの設計思想（監視者アーキテクチャ）**を定義するものである。
目的は、機能追加や修正、デバッグ作業を行うすべての開発者が共通の設計原則を理解し、アプリケーションの堅牢性、保守性、拡張性を維持・向上させることにある。

### 2. 設計思想： すべての判断は「監視者」に委ねよ

本アプリケーションのすべての状態遷移とUI更新は、唯一の**「監視者」**である`battle-logic.js`内の`determineNextStep()`関数にその判断が委ねられる。

*   **各モジュールの責務:**
    *   **`interaction-manager.js` (UIイベント担当):** ユーザーの操作（クリックなど）を検知し、そのアクションが何を意図しているか（例：「インデックス2のアクションを解決したい」）を`battle-logic.js`に**依頼するだけ**に留める。**自ら戦闘状態を変更したり、UIを直接更新する命令を出してはならない。**
    *   **`battle-logic.js` (ロジック担当):** `interaction-manager.js`から依頼された処理（アクションの解決、ダメージの適用など）を実行し、戦闘の状態（`battleState`）を更新する。そして、処理が完了したら、**必ず最後に「監視者」である`determineNextStep()`を呼び出し、再評価を依頼する。**
    *   **`determineNextStep()` (監視者):** 現在の`battleState`（フェーズ、各種キューの状態、キャラクターの行動値など）を**総合的に評価**し、アプリケーションが次に取るべき状態（フェーズ遷移、UIの完全更新など）を**決定し、命令する。** UI更新の命令は、原則としてこの関数からのみ発行される。
    *   **`ui-manager.js` (UI描画担当):** `determineNextStep()`からの命令に基づき、現在の状態を画面に描画すること**だけに専念する。** 自ら能動的に状態を判断してはならない。

**フローの概念図:**
```
(ユーザー操作)
      |
      v
[interaction-manager] -> 「この処理をお願いします」と依頼 -> [battle-logic の各種関数]
                                                                   |
                                                                   v
                                                             (状態(battleState)を更新)
                                                                   |
                                                                   v
                                       +-------------------> [determineNextStep (監視者)] --+
                                       |                           |                      |
                                       |                           v                      |
                                       +-- 「再評価してください」-- (状態を総合的に判断)     |
                                                                   |                      |
                                                                   v                      |
                                                 「この内容で画面を描画してください」      |
                                                                   |                      |
                                                                   v                      |
                                                               [ui-manager] <-------------+
```

### 3. バトルロジック追加作成時における着意事項（開発ルール）

#### ルール1： 新しい処理は「単発」で完結させること

新しく作成する関数（例：`applySpecialEffect()`）は、必ず**一つの明確な責務**だけを持ち、その処理が完了したら速やかに終了すること。
関数の内部で、別の状態遷移を引き起こす関数（`advancePhase()`など）を直接呼び出すことは**厳禁**とする。

**悪い例（逐次処理）:**
```javascript
function applyEffect() {
    // 状態Aを変更
    battleState.effectApplied = true;
    
    // 変更した結果、次のフェーズに進むべきかを「自分で」判断している (★NG)
    if (shouldAdvance()) {
        advancePhase(); // ★NG: 監視者を無視した直接命令
    }
}
```

**良い例（監視者への報告）:**
```javascript
function applyEffect() {
    // 状態Aを変更する、という自分の仕事だけを行う
    battleState.effectApplied = true;

    // 仕事が終わったので、監視者にお伺いを立てる
    determineNextStep(); 
}
```

#### ルール2： UIの更新は `determineNextStep()` に一任すること

新しい処理の結果、UIに何らかの変更（マーカーの移動、カウンターの表示など）が必要になったとしても、処理関数の中で直接`ui-manager`の関数を呼び出してはならない。
UIの更新は、すべての状態変更が完了した後、**最後に`determineNextStep()`が一度だけ**行う。これにより、UIの描画競合や更新漏れを完全に防ぐ。

**悪い例（個別更新）:**
```javascript
function moveCharacterOnBoard(charId, newArea) {
    const character = charManager.getCharacterById(charId);
    character.area = newArea;
    ui.updateMarkers(); // ★NG: 個別のUI更新
    determineNextStep();
}
```

**良い例（状態変更のみ）:**
```javascript
function moveCharacterOnBoard(charId, newArea) {
    const character = charManager.getCharacterById(charId);
    character.area = newArea; // 状態を変更するだけ
    determineNextStep(); // あとは監視者がマーカーの更新も指示してくれる
}
```

#### ルール3： 状態の判断は `determineNextStep()` の冒頭で行うこと

`determineNextStep`は、関数の**冒頭**で、現在の`battleState`から必要な情報をすべて変数として計算・保持する。
その後の`switch`文などでは、これらの**計算済み変数**を使って判断を行うこと。これにより、判断基準が一箇所にまとまり、可読性が向上する。

```javascript
function determineNextStep() {
    // --- ▼ 冒頭ですべての情報を計算する ▼ ---
    const actingCharacters = characters.filter(...);
    const allRapidsChecked = battleState.rapidQueue.every(...);
    const allActionsChecked = battleState.actionQueue.every(...);
    const pendingDamageExists = battleState.damageQueue.some(...);
    // --- ▲ 計算はここまで ▲ ---

    // --- ▼ 計算済みの変数を使って判断する ▼ ---
    switch (battleState.phase) {
        case 'JUDGE_RESOLUTION':
            if (allActionsChecked) { // 状態を再チェックするのではなく、変数を使う
                if (pendingDamageExists) {
                    // ...
                }
            }
            break;
    }
    // ...
}
```

### 4. まとめ

このアーキテクチャは、**「状態を変更する処理」**と**「状態を評価して次の行動を決定する処理」**を完全に分離することで、複雑な戦闘フローをシンプルで予測可能なものにする。
新しい機能を追加する際は、常に**「これは『処理』か？それとも『判断』か？」**を自問し、「処理」であれば単発の関数として作成して最後に`determineNextStep()`を呼び出し、「判断」であれば`determineNextStep()`の中に追加することを徹底すること。