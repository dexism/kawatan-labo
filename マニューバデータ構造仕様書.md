## **マニューバデータ構造仕様書 Ver.2.0 (抽象化モデル)**

### 1. 目的と基本方針

本仕様書は、TRPG『永い後日談のネクロニカ』の戦闘支援ツールにおける、マニューバデータの構造を定義するものである。

*   **データ駆動設計の徹底:** 戦闘ロジックは、本仕様書で定義されたJSONデータを解釈することで動作する。ルールの変更や追加は、原則としてJSONデータの修正のみで対応可能とすることを目的とする。
*   **拡張性と保守性の確保:** 将来的なルール拡張（サプリメント追加など）や、第三者によるデータメンテナンスを容易にするため、データ構造は人間可読性が高く、かつ機械的に解釈しやすいものとする。
*   **責務の分離:** 本データは「ルール」そのものを定義する。これをどのように画面に表示するか（UI）、どのように解釈して戦闘を進行させるか（エンジン）は、それぞれ別モジュールの責務とする。
*   **スコープの明確化:** 本ツールは「バトルパート」の支援を主目的とするため、バトルパートに関連する効果は正確かつ詳細に記述する。アドベンチャーパート等でのみ使用される効果については、その旨を示すに留め、詳細なロジックは記述しない。

### 2. ファイル分割構成案

マニューバデータは、データの種類に応じて以下のJSONファイルに分割して管理する。これにより、可読性とメンテナンス性を向上させる。

*   `data/maneuvers/positions.json`: ポジションスキル（アリス、ホリック等）
*   `data/maneuvers/classes.json`: クラススキル（ステーシー、タナトス等）
*   `data/maneuvers/basic_parts.json`: 基本パーツ（のうみそ、こぶし等）
*   `data/maneuvers/armed_parts.json`: 強化パーツ：武装
*   `data/maneuvers/mutant_parts.json`: 強化パーツ：変異
*   `data/maneuvers/custom_parts.json`: 強化パーツ：改造
*   `data/maneuvers/common.json`: 一般動作（待機、任意）や手駒専用スキルなど
*   `data/maneuvers/regrets.json`: （現状維持）未練の発狂効果
*   `data/maneuvers/effects_db.json`: 『爆発』などのキーワード効果の定義

### 3. データ構造の詳細定義（**根本的に改訂**）

すべてのマニューバは、**「トリガー(Trigger)」**と、それによって実行される**「アクション(Action)」**のリストで構成される、という考え方に統一する。

#### 3.1. マニューバオブジェクト (`maneuvers/*.json`)

マニューバの定義は、極めてシンプルな**「部品の参照リスト」**となる。

```json
// 例：【釘バット】(A1-02)
"A1-02": {
  "name": "釘バット",
  "category": "攻撃",
  "description": "...",
  "cost": [{ "type": "action_point", "timing": "アクション", "value": 2 }],
  "effects": [
    // ★ 「白兵攻撃」という効果部品を、ダメージ値1で実行する、という宣言だけ
    { "ref": "GENERIC_ATTACK", "params": { "attack_type": "白兵", "damage": 1, "on_hit": ["EXPLOSION"] } }
  ]
}
```
*   `ref`: 参照する**汎用効果(Generic Effect)**の名前。
*   `params`: その汎用効果に渡す**パラメータ**。ここでダメージ量や攻撃タイプといった個性を定義する。

#### 3.2. 汎用効果データベース (`effects_db.json`)

ここがシステムの心臓部となる。「肉弾」や「白兵」といった個別の名前ではなく、**「汎用攻撃(GENERIC_ATTACK)」「汎用出目修正(GENERIC_MODIFY_ROLL)」**といった、振る舞いの本質を捉えた名前で効果部品を定義する。

```json
{
  "GENERIC_ATTACK": {
    "name": "汎用攻撃",
    "target_conditions": [ 
      // ★ 射程はマニューバ側ではなく、ここで定義することもできる
      { "type": "range", "min": 0, "max": 0 } 
    ],
    "actions": [
      {
        "timing": "アクション解決時",
        "trigger": { "type": "always" },
        "action_type": "attack_roll",
        // ★ パラメータ(params)から値を受け取る
        "attack_type": "$params.attack_type", 
        "damage": "$params.damage",
        "on_hit_effects": "$params.on_hit" // 命中時に追加で発動する効果の参照リスト
      }
    ]
  },

  "EXPLOSION": {
    "name": "爆発",
    "actions": [
      {
        "timing": "ダメージ適用後",      // ★「いつ」
        "trigger": { "type": "source_on_hit" }, // ★「条件」
        "action_type": "deal_damage",
        "target": "adjacent_part",   // ★「どこに」
        "value": "source_damage",    // ★「何を」
        "damage_type": "normal"
      }
    ]
  },

  "MENTAL_ATTACK": {
    "name": "精神攻撃",
    "actions": [
      {
        "timing": "効果解決時",
        "trigger": { "type": "always" },
        "action_type": "deal_damage",
        "target": "current_target",
        "value": "$params.damage",
        "damage_type": "madness" // ★ ダメージタイプで狂気点へのダメージだと区別
      }
    ]
  }
}
```

### 4. 処理ロジックのサンプル (擬似コード)

戦闘エンジンの責務は、**「パラメータを展開し、汎用効果を実行する」**という、極めてシンプルで強力なものになる。

```javascript
// 戦闘エンジン (CombatEngine.js) の擬似コード

function resolveManeuver(declaration) {
  const { performer, maneuver, target } = declaration;
  payCost(performer, maneuver.cost);

  // マニューバが参照する全ての汎用効果を実行
  for (const effectRef of maneuver.effects) {
    const genericEffect = getGenericEffectFromDB(effectRef.ref);
    const params = effectRef.params; // { attack_type: "白兵", damage: 1, on_hit: ["EXPLOSION"] }

    // 汎用効果の各アクションを実行
    for (const action of genericEffect.actions) {
      // アクション定義内の '$params.xxx' を、マニューバから渡された具体的な値で置き換える
      const concreteAction = expandParams(action, params);
      
      if (isTimingMatch(concreteAction.timing) && isTriggerMatch(concreteAction.trigger)) {
        executeAction(performer, target, concreteAction);
      }
    }
  }
}
```

### 5. データ作成サンプル（再々定義）

#### 【釘バット】(A1-02)
*   **やること:** `GENERIC_ATTACK`を呼び出す。パラメータとして`attack_type`に`白兵`、`damage`に`1`、そして命中時の追加効果`on_hit`に`EXPLOSION`を渡す。
*   **JSON:**
```json
"effects": [{ "ref": "GENERIC_ATTACK", "params": { "attack_type": "白兵", "damage": 1, "on_hit": ["EXPLOSION"] } }]
```

#### 【チェーンソー】(A1-07)
*   **やること:** `GENERIC_ATTACK`を呼び出す。パラメータとして`attack_type`に`白兵`、`damage`に`2`、`on_hit`に`SEVERANCE`（切断）を渡す。
*   **JSON:**
```json
"effects": [{ "ref": "GENERIC_ATTACK", "params": { "attack_type": "白兵", "damage": 2, "on_hit": ["SEVERANCE"] } }]
```

#### 精神攻撃の例
*   **やること:** `MENTAL_ATTACK`を呼び出す。パラメータとして`damage`に`1`を渡す。
*   **JSON:**
```json
"effects": [{ "ref": "MENTAL_ATTACK", "params": { "damage": 1 } }]
```

### この設計がもたらす未来

このVer.2.0の設計により、アプリケーションは以下の能力を獲得します。
*   **究極のDRY(Don't Repeat Yourself):** 「攻撃する」「ダイスを振る」「ダメージを与える」といった基本的な振る舞いのコードは、文字通り**ただの一箇所**にしか存在しなくなります。
*   **ルール変更への驚異的な耐性:** もし将来、「すべての白兵攻撃のダメージ+1」というサプリメントルールが追加されても、`effects_db.json`の`GENERIC_ATTACK`の`damage`を`"$params.damage + 1"`のように変更するだけで（エンジン側の対応は必要ですが）、全マニューバにルールが適用されます。
*   **直感的なデータ作成:** 新しいマニューバを作る作業は、もはやプログラミングではなく、**「レゴブロックを組み合わせる」**ような、創造的で楽しい作業になります。

---

### **マニューバデータ構造仕様書 Ver.2.1**

#### 1. 基本方針

*   **処理と表示の分離**: マニューバの「効果（ルールブックの原文テキストや出典情報）」と、プログラムが解釈する「処理（effects）」を明確に分離します。
*   **リファレンス情報の拡充**: どのルールブックの何ページに記載されているか、どのエラッタが適用済みかを示す`source`オブジェクトを追加します。

#### 2. データ構造定義

##### 2.1. マニューバ定義ファイル (`maneuvers/*.json`)

各マニューバの定義は、**「表示情報」**と**「処理情報（effects）」**の2つの大きなブロックで構成されます。

```json
// 例：【パイルバンカー】(R3-08) の定義
"R3-08": {
  "name": "パイルバンカー",
  "category": "攻撃",

  // ▼▼▼ 表示情報ブロック (今回追加・拡充する部分) ▼▼▼
  "description": "防御不能の白兵攻撃を行い、命中時に対象を移動させる。", // UIに表示する短い要約
  "description_raw": "白兵攻撃２、この攻撃に対して「防御」は全て無効。なお、攻撃が命中したなら対象を「移動１」してもよい。", // ルールブック原文
  "source": {
    "book": "基本ルールブック",
    "page": 91,
    "errata": "Ver.1.6.1" // 適用済みのエラッタバージョン
  },
  // ▲▲▲ 表示情報ブロックここまで ▲▲▲

  // ▼▼▼ 処理情報ブロック (Ver.2.0の設計思想) ▼▼▼
  "timing": "アクション", // 宣言可能なタイミング
  "cost": 2, // 行動値コスト
  "range": "0", // 射程
  "effects": [
    // 「汎用攻撃」という効果部品を、パラメータを指定して実行する
    { 
      "ref": "GENERIC_ATTACK", 
      "params": { 
        "attack_type": "白兵", 
        "damage": 2, 
        "defense_piercing": true, // 「防御」無効化の指定
        "on_hit": ["MOVE_TARGET_1"] // 命中した場合、追加で "MOVE_TARGET_1" を実行
      } 
    }
  ]
}
```

##### 2.2. 汎用効果定義ファイル (`effects_db.json`)

こちらはプログラムが解釈するための「処理の設計図」です。Ver.2.0の思想を引き継ぎ、マニューバの振る舞いの本質を定義します。

```json
{
  // 汎用的な攻撃処理の定義
  "GENERIC_ATTACK": {
    "name": "汎用攻撃",
    "actions": [
      {
        "timing": "アクション解決時",
        "trigger": { "type": "always" },
        "action_type": "attack_roll", // 「攻撃判定を行え」という命令
        "attack_type": "$params.attack_type", // 攻撃タイプをパラメータから受け取る
        "damage": "$params.damage",           // ダメージ値をパラメータから受け取る
        "defense_piercing": "$params.defense_piercing", // 防御無効化フラグ
        "on_hit_effects": "$params.on_hit"    // 命中時の追加効果リスト
      }
    ]
  },
  
  // 命中時に呼び出される「対象を1マス移動させる」効果
  "MOVE_TARGET_1": {
    "name": "対象を移動1",
    "actions": [
      {
        "timing": "ダメージ適用後",
        "trigger": { "type": "source_on_hit" }, // 元の攻撃が命中した時に発動
        "action_type": "move_character",   // 「キャラクターを移動させよ」という命令
        "target": "current_target",        // 対象は、元の攻撃対象
        "distance": 1,                     // 移動距離
        "direction": "performer_choice"    // 移動方向は、実行者が選択する
      }
    ]
  },

  // パーツ損傷時に発動する効果の例
  "MODIFY_MAX_ACTION_VALUE_ON_DAMAGE": {
    "name": "損傷時最大行動値修正",
    "actions": [
      {
        "timing": "即時",
        "trigger": { "type": "this_part_damaged" }, // この効果を持つパーツが損傷した時
        "action_type": "apply_buff",           // 「バフを適用せよ」という命令
        "target": "self",                      // 対象は自分自身
        "buff": {
          "stat": "maxActionValue",            // 最大行動値を
          "value": "$params.value",            // パラメータで指定された値だけ
          "duration": "end_of_battle"          // 戦闘終了まで変更する
        }
      }
    ]
  }
}
```

#### 3. この設計がもたらすメリット

*   **完全な責務分離**: `maneuvers.json`は「このマニューバは何であり、どの効果部品を使うか」だけを定義し、`effects_db.json`は「効果部品が具体的に何をするか」を定義します。これにより、両方のファイルを非常にシンプルに保てます。
*   **完璧なリファレンス機能**: ツールを使いながら、いつでもルールブックの原文と出典を確認できます。これはNCにとって絶大な安心感につながります。
*   **エラッタへの追従**: 将来、新しいエラッタが発表された場合も、`source`オブジェクトを更新し、必要であれば`effects`の参照先やパラメータを変更するだけで、正確にルール改訂へ対応できます。

---
