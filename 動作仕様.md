## **『永い後日談のネクロニカ』NC用バトルパート支援ツール 機能仕様書**

### **第X章 セッションモード**

### 1. 概要

本機能は、複数のPC（プレイヤー）が各自の端末から戦闘に参加し、NC（ネクロマンサー）の端末とリアルタイムにデータを同期するためのマルチプレイ機能である。「セッションモード」として実装され、1台のNC端末（サーバー役）と最大5台のPL端末（クライアント役）間での戦闘進行を可能にする。

静的サーバー環境（例: Netlify）での運用を前提とし、P2P（ピアツーピア）通信技術を利用して、NCのブラウザをセッション中の擬似的なサーバーとして機能させる。

### 2. モード定義と役割

本ツールには、以下の2つの動作モードが存在する。

*   **NCモード（サーバー役）**
    *   **役割**: セッションのホスト。戦闘に関する全ての公式な状態（**現況データ**）を管理し、PL端末からの操作要求を処理し、更新された現況を全PL端末に配信する責任を持つ。
    *   **定員**: 1セッションにつき1名。
    *   **主な権限**:
        *   手駒（敵キャラクター）の追加、ステータス管理、マニューバ宣言。
        *   ターン、カウント、戦闘フェーズ（タイミング）の進行管理。
        *   PLから受信したマニューバ宣言の承認と解決（ダイスロールの実行、ダメージ処理など）。
        *   更新された「現況データ」の全PL端末への配信。
        *   セッション全体のデータ管理（戦闘開始、終了、リセット）。

*   **PLモード（クライアント役）**
    *   **役割**: セッションの参加者。NCモードの端末に接続し、同期された現況データを表示する。自身の担当するドール（キャラクター）に対する操作を行い、その結果をNCに送信する。
    *   **定員**: 1セッションにつき最大5名。
    *   **主な権限**:
        *   NCが配置した姉妹ドールの中から、自身の担当キャラクターを1体選択し、管理下に置く。
        *   管理下にあるドールのマニューバ宣言（アクション、ラピッド、ジャッジ、ダメージ）。
        *   NCからの指示に基づく各種処理の実行（損傷パーツの選択、狂気点を追加する未練の選択など）。
        *   NCからの要求に応じた判定のためのダイスロール実行と結果の送信。

### 3. データフローと通信の基本設計

セッション中のデータは、**NC端末を「正」**とし、PL端末はそれを受信して表示する一方向の流れを基本とする。

1.  **接続確立**: PL端末は、NC端末から共有された接続情報（セッションIDなど）を用いて、NC端末への通信チャネルを確立する。
2.  **現況データの同期**: 接続が確立されると、PL端末はNC端末から最新の「現況データ」を受信し、自身の画面を完全に同期させる。
3.  **PLからの操作要求**:
    *   PLが自身のドールのマニューバを宣言すると、PL端末は「【誰が】どのマニューバを【誰に】使いたいか」という**宣言内容（操作要求）**をNC端末に送信する。
    *   この時点では、PL端末の画面上のキャラクターの行動値などはまだ変化しない。
4.  **NCによる解決と現況更新**:
    *   NC端末は、PL端末から受信した操作要求をキューに追加・表示する。
    *   NCは自身の判断とルールに基づき、宣言を解決（ダイスロールの実行、ダメージ計算など）し、キャラクターのステータスや戦場の状況を更新する。この更新された状態が新しい「現況データ」となる。
5.  **現況データの配信**:
    *   NC端末は、現況データが更新されるたびに、その最新データを接続している全てのPL端末に配信する。
6.  **PL端末の画面更新**:
    *   PL端末は、NC端末から新しい現況データを受信するたびに、自身の画面全体をそのデータに基づいて再描画する。これにより、全参加者の画面が常に同期された状態に保たれる。

```mermaid
sequenceDiagram
    participant PL as PL端末
    participant NC as NC端末 (サーバー役)

    PL->>NC: 接続要求（セッションID）
    NC-->>PL: 接続承認
    NC-->>PL: 最新の「現況データ」を送信

    loop 戦闘中
        PL->>NC: マニューバ宣言（操作要求）
        NC->>NC: 宣言をキューに追加
        NC->>NC: NCが宣言を解決（ダイスロール等）
        NC->>NC: 「現況データ」を更新
        NC-->>PL: 更新された「現況データ」を配信
        PL->>PL: 受信したデータで画面を再描画
    end
```

### 4. データ管理仕様

*   **セッション中のデータソース**:
    *   セッションが一度開始された後は、全てのキャラクターデータ（スキル、パーツ、未練など）は**NC端末上のデータ**を唯一の正本とする。
    *   セッション中に「保管所から再読込」機能は使用不可（または使用してもNC端末のデータにのみ影響し、PL端末には影響しない）とする。PL端末側でのデータ変更は一切許可されない。

*   **現況データに含まれる主な情報**:
    *   全キャラクター（PC、手駒）の全ステータス（HP、行動値、位置、状態異常、損傷状態など）。
    *   現在のターン、カウント、戦闘フェーズ。
    *   各種宣言キュー（アクション、ラピッド、ジャッジ、ダメージ）の内容。
    *   戦闘ログ。

### 5. UI/UXに関する仕様

*   **モード選択**: アプリケーション起動時に「NCモードで開始」するか「PLモードで参加」するかを選択するUIを設ける。
*   **NCモードUI**:
    *   セッションID（または接続用URL）を生成し、PLに共有するための表示領域を設ける。
    *   接続中のPL一覧を表示するパネルを設ける。
    *   PLから受信した宣言を、手駒の宣言と同様に各種宣言キューに表示する。その際、誰からの宣言か識別できるようにする（例：PL名を表示）。
*   **PLモードUI**:
    *   セッションIDを入力して接続するためのUIを設ける。
    *   接続後、まだ誰にも管理されていないPCの一覧を表示し、自身のキャラクターを選択させる。
    *   管理下のキャラクター以外の操作パネルは、原則として無効化（表示のみ）する。
    *   自身の行動タイミングになると、マニューバメニューが操作可能になる。
    *   宣言後は、NCが解決するまで待機状態となることを示すUI（例：宣言キューに「承認待ち」と表示）を設ける。

``` javascript
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyA-BGPA0Ym9pUAuBPTrSYvMYjW5orT8v9U",
  authDomain: "nechronica-st.firebaseapp.com",
  databaseURL: "https://nechronica-st-default-rtdb.firebaseio.com",
  projectId: "nechronica-st",
  storageBucket: "nechronica-st.firebasestorage.app",
  messagingSenderId: "482404051345",
  appId: "1:482404051345:web:2ca518f33dadc4d8f5d230",
  measurementId: "G-LKEH0S06E3"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
```
ルール
``` json
{
  "rules": {
    "rooms": {
      "$sessionID": {
        // セッションIDを知っているユーザーのみが読み書き可能
        ".read": true,
        ".write": true,
        "nc": {
          // NCは誰でも書き込める（最初のオファー作成）
          ".write": true
        },
        "pls": {
          "$plID": {
            // PLは自身のIDのパスにのみ書き込める
            // (より厳密にするならFirebase Authと組み合わせる)
            ".write": true
          }
        }
      }
    },
    "logs": {
      ".read": true,   // ログの読み取りも許可（デバッグ用に便利）
      ".write": true   // ★★★ ログの書き込みを許可する ★★★
    }
  }
}
```

---

### **セッションモード UI/UX仕様書 (改訂版)**

#### 1. 基本的な画面フロー

アプリケーションは常に「オフラインモード」で起動します。セッション機能は、ユーザーが任意のアクションを起こすことで開始されます。

```mermaid
graph TD
    A[起動 (オフラインモード)] --> B{NCとして<br>セッションを開始？};
    A --> C{PLとして<br>セッションに参加？};

    B -- No --> A;
    C -- No --> A;

    B -- Yes --> D[NCモードへ移行];
    C -- Yes --> E[PLモードへ移行];

    D --> F[戦闘進行];
    E --> F;
```

#### 2. NCモードへの移行フロー

**トリガー**: NCが戦闘準備を整え、「セッションを開始」ボタンをクリックする。

**UI要素（設定パネル内）:**

1.  **通常起動時（オフラインモード）**
    *   設定パネル内に**「セッションを開始する」**ボタンを配置します。このボタンは最初は無効化（`disabled`）されています。

2.  **ボタンの有効化条件**:
    *   戦場に**PCが1体以上**かつ**手駒が1体以上**配置された時点で、「セッションを開始する」ボタンが有効になります。
    *   このチェックは、キャラクターが追加・削除されるたびに実行されます。

3.  **「セッションを開始する」ボタンクリック後の動作**:
    *   クリックすると、以下の処理が実行されます。
        a.  0000〜9999のランダムな4桁のルーム番号を生成します。
        b.  Firebase Realtime Databaseにアクセスし、そのルーム番号が既に使用されていないか確認します。
            *   もし使用中であれば、別の番号で再試行します。
        c.  空いているルーム番号が見つかったら、その番号でFirebase上に新しいルームデータを作成し、ツールが**NCモード**に移行します。
    *   UIが**「NCモード・セッション管理パネル」**に切り替わります。

**NCモード・セッション管理パネルのUI:**

*   タイトル: 「NCモード：セッション管理」
*   ルーム番号表示: **`ルーム番号: XXXX`** のように、確定した4桁の番号を大きく表示します。
*   招待URL表示:
    *   読み取り専用テキストボックス: `https://[あなたのサイト].netlify.app/?room=XXXX`
    *   **「招待URLをコピー」ボタン**
*   接続中PLリスト: 接続したPLの名前を一覧表示。
*   「セッションを終了」ボタン

**操作フロー (NC):**
1.  ツールを起動し、通常通り「ファイルから読込み」や手動でPCと手駒を戦場に配置する。
2.  配置が完了すると「セッションを開始する」ボタンが有効になるので、それをクリックする。
3.  自動でルーム番号が割り当てられ、画面がNCモードに切り替わる。
4.  「招待URLをコピー」ボタンを押し、参加者にURLを共有する。
5.  PLの接続を待ち、全員が揃ったら戦闘を開始する。

#### 3. PLモードへの移行フロー

**トリガー**: ユーザーが招待URLからアクセスするか、手動でルーム番号を入力する。

**フローA: 招待URLから参加する場合（推奨）**

1.  PLはNCから共有されたURL (`?room=XXXX`付き) をクリックしてページを開きます。
2.  JavaScriptがURLの`room`パラメータを検知し、自動的に**PLモード**に移行します。
3.  画面には「ルームXXXXに接続中...」というメッセージが表示され、バックグラウンドで接続処理が開始されます。
4.  接続が成功すると、キャラクター選択モーダルが表示されます。

**フローB: ルーム番号を手動で入力する場合**

**UI要素（設定パネル内）:**
*   **通常起動時（オフラインモード）**
    *   設定パネル内に「セッションに参加」セクションを設けます。
    *   **ルーム番号入力欄**: 4桁の数値を入力できるテキストボックス。
    *   **「参加する」ボタン**

**操作フロー (PL):**
1.  ツールを通常通り起動する。
2.  設定パネルを開き、NCから口頭やチャットで伝えられた4桁のルーム番号を入力する。
3.  「参加する」ボタンをクリックする。
4.  ツールが**PLモード**に移行し、フローAと同様に接続処理とキャラクター選択が開始されます。

#### 4. 実装に向けた具体的な関数・イベントの整理

このUIフローを実現するために、以下の様な関数やイベントハンドラが必要になります。

*   **`character-manager.js` / `ui-manager.js`**:
    *   キャラクターの追加・削除時に`checkSessionStartButtonState()`のような関数を呼び出し、「セッションを開始する」ボタンの有効/無効を切り替える。

*   **`interaction-manager.js`**:
    *   「セッションを開始する」ボタンの`onclick`イベントで、`p2pManager.startHostSession()`のような関数を呼び出す。
    *   「参加する」ボタンの`onclick`イベントで、入力されたルーム番号を引数に`p2pManager.joinClientSession(roomId)`のような関数を呼び出す。

*   **`script.js` (または `settings-manager.js`)**:
    *   ページ読み込み時（`DOMContentLoaded`）に、URLに`room`パラメータが存在するかをチェックし、存在すれば自動的にPLモードのフローを開始する。

---

## **オンラインセッション 通信規約 Ver.1.1**

### 1. 基本方針 (変更なし)

1.  **NC端末の絶対性**: セッションにおける全ての公式な状態（**現況データ**）は、**NC端末が唯一の正本（Source of Truth）**として管理する。
2.  **PLからの操作は「要求」**: PL端末が行う操作は、NC端末に対する**「操作要求」**として送信される。
3.  **状態更新の一元化**: 全ての操作要求はNC端末で処理・検証され、更新された現況データがNC端末から全PL端末へ**ブロードキャスト**される。
4.  **通信量の最小化**: 状態が変化した重要なタイミングでのみデータを送信する。**カウント進行中は宣言要求とダイス結果の通報に限り**、現況データの完全な同期は**カウント開始時**にまとめて行うことを原則とする。

### 2. データ種別ごとの通信規定

| データ種別 | トリガー | 送信元 → 宛先 | 送信するデータ（ペイロード） | 備考 |
| :--- | :--- | :--- | :--- | :--- |
| **【更新】現況データ** | 接続確立時、**カウント開始時** | NC → 全PL | **`{ type: 'gameStateUpdate', payload: battleState }`** <br> ・全キャラクターの完全な状態 <br>・戦闘のターン、カウント、フェーズ情報 <br>・全ての宣言キューの内容 | セッションの根幹データ。PL端末はこのデータで自身の状態を完全に上書き同期する。**カウント進行中は原則送信しない。** |
| **マニューバ宣言要求** | PLがマニューバを宣言 | PL → NC | **`{ type: 'declareManeuver', payload: { performerId, maneuverName, targetId, ... } }`** | NCはこの要求を検証し、宣言キューに追加。追加後のキュー情報のみを**差分更新**として全PLに送信する場合がある。(下記「宣言キュー更新」参照) |
| **【新設】宣言キュー更新** | NCが宣言を受理 | NC → 全PL | **`{ type: 'queueUpdate', payload: { actionQueue, rapidQueue, ... } }`** | 現況データ全体ではなく、更新されたキュー情報のみを送信する軽量なデータ。これによりカウント進行中のリアルタイム性を担保する。 |
| **【新設】ダイスロール許可** | NCがPLの攻撃宣言などを解決 | NC → 特定PL | **`{ type: 'requestDiceRoll', payload: { command: "NA+2", declarationId, ... } }`** | PL端末はこの受信をトリガーに3Dダイスを表示する。`declarationId`でどの宣言に対する判定かを紐付ける。 |
| **【新設】ダイスロール要求** | (任意) PLが能動的な判定を希望 | PL → NC | **`{ type: 'requestRollPermission', payload: { command: "NC" } }`** | 将来的な行動判定の実装などで使用。NCはこれを受け取り、`requestDiceRoll`を返すか判断する。 |
| **【新設】ダイス結果通報** | PL端末でダイスロールが完了 | PL → NC | **`{ type: 'reportDiceResult', payload: { result, hitLocation, rollValue, declarationId } }`** | NCはこの結果を用いてダメージ計算などを行い、解決後のログや更新された現況データをブロードキャストする。 |
| **未練・狂気点変更要求** | PLが狂気点の追加先を選択など | PL → NC | **`{ type: 'updateRegret', payload: { characterId, regretId, ... } }`** | NCはこの要求を処理し、更新後の**キャラクターデータ差分**または完全な現況データをブロードキャストする。 |
| **アンデッド選択** | PLが操作対象のキャラクターを選択 | PL → NC | **`{ type: 'claimCharacter', payload: { characterId } }`** | NCはキャラクターに操作者情報を紐付け、更新後の現況データをブロードキャストする。 |
| **【更新】画像要求** | PL端末にキャッシュされていない画像が必要 | PL → NC | **`{ type: 'requestImage', payload: { characterId } }`** | **個別要求**に変更。一度に複数ではなく、1キャラクターずつ要求することで、サーバー負荷とデータ量を分散させる。 |
| **【更新】画像データ配信** | NCが`requestImage`を受信 | NC → 要求元PL | **`{ type: 'distributeImage', payload: { characterId, imageDataUrl } }`** | **要求元のPLにのみ**送信する。Base64データはサイズが大きいためブロードキャストを避ける。 |
| **【新設】ハートビート** | 定期実行 (例: 5秒ごと) | 全端末 相互 | **`{ type: 'ping', payload: { timestamp } }`** (相手からは`pong`) | 接続維持を確認するための軽量な死活監視データ。応答がない場合、接続が切れたと判断するトリガーになる。 |
| **通知・ログ** | ダイスロール解決後、PLの入退室など | NC → 全PL | **`{ type: 'notification', payload: "メッセージ" }`** | 主にログ表示やトースト通知に使用。 |

### 3. ダイスロールのシーケンス

PLのアクションがダイスロールを伴う場合の、標準的な通信フロー。

```mermaid
sequenceDiagram
    participant PL as PL端末
    participant NC as NC端末

    PL->>NC: マニューバ宣言要求 (例: 攻撃)
    NC->>NC: 宣言をキューに追加
    NC-->>PL: 宣言キュー更新 (ブロードキャスト)
    
    Note over NC: NCが解決フェーズに進み、<br>PLの宣言を解決する番になる
    
    NC-->>PL: ダイスロール許可 (特定のPLへ)
    PL->>PL: 3Dダイスを表示・ロール実行
    PL->>NC: ダイス結果通報
    
    NC->>NC: 結果を基にダメージ計算など<br>現況データを更新
    NC-->>PL: ログ通知 (ブロードキャスト)
    Note over NC: カウント開始時などに<br>完全な現況データを送信```

### 4. ルーム入室・再接続時の動作シーケンス (変更なし)

PL端末がルームに接続（または再接続）する際の動作フローは、前回の規約 Ver.1.0 と同様とする。

1.  **起動**: `localStorage`から「プレイヤーID」「セッションID」を確認。
2.  **自動再接続**: セッションIDがあれば、ウェルカムモーダル等をスキップして直ちに接続を開始し、`requestInitialState`を送信。
3.  **NCの応答**: `requestInitialState`に対し、要求元のPLにのみ完全な**現況データ**を返信する。
4.  **PL端末の初期化**: 受信した現況データで画面を構築。キャッシュにない画像があれば、`requestImage`を**個別に**送信する。
5.  **キャラクター選択**: 操作対象を選択し、`claimCharacter`を送信。NCからの現況データ更新を受けて、UIの操作を有効化する。

---
