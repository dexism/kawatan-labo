### **`interaction-manager.js` の役割**

このモジュールの主な責務は2つです。

1.  **ユーザー操作の受付（入力）**: ユーザーが画面上で行うあらゆる操作（クリック、ドラッグ、マウスオーバーなど）を受け付けるための**イベントリスナー**を管理します。
2.  **UI表示の指示（出力）**: 受け付けた操作に応じて、**マニューバメニューや各種モーダル（詳細シート、画像選択など）を構築**し、`ui-manager.js`に表示を依頼します。また、操作の結果を`battle-logic.js`に伝達する**橋渡し役**も担います。

---

### **主要な機能の分類と概要**

#### 1. 初期化とイベントリスナー設定

アプリケーション起動時やUI更新時に呼び出され、様々な要素を操作可能にするための関数群です。

| 関数名 | 機能概要 |
| :--- | :--- |
| `initialize()` | モジュールの初期化を宣言するだけのシンプルな関数です。 |
| `setupAllEventListeners()` | アプリケーション全体のイベントリスナーをセットアップする統括関数です。`script.js`から一度だけ呼び出され、以下のセットアップ関数をすべて実行します。カード外クリック時の選択解除リスナーもここに設定されています。 |
| `setupCharacterEventListeners()` | **（重要）** 戦場にいる全てのキャラクターカード（`.char`）とグリッド上のマーカー（`.marker`）にイベントリスナーを設定します。**UIが再描画されるたびに呼び出され**、新しい要素にもイベントを設定し直します。戦闘中か戦闘準備中かで、クリックされたときの挙動（メニュー表示 or ボタン表示）を切り替えるロジックも内包しています。 |
| `setupDragToScroll()` | PC・手駒エリアのコンテナを、マウスドラッグで横スクロールできるようにします。 |
| `setupDiceRollerEventListeners()` | 画面右下のダイスローラーアイコンをドラッグで移動可能にし、クリックでダイスメニューが開くようにします。 |
| `setupAccordion()` | 右側パネルの各宣言リストなどが、クリックで開閉（アコーディオン）できるようにします。 |
| `setupMadnessModalEventListeners()` | ターン終了時の狂気点モーダル内の各項目に、選択状態を管理するためのクリックイベントを設定します。 |

#### 2. UI構築（メニューとモーダル）

ユーザーのアクションに応じて、専門的なUI（メニューやモーダル）を動的に構築し、表示する関数群です。

| 関数名 | 機能概要 |
| :--- | :--- |
| `buildManeuverMenu()` | **（最重要）** キャラクターがクリックされた際に、そのキャラクターが使用可能なマニューバのリストを構築し、メニューとして表示します。損傷状態、タイミング、使用回数、対象の有無などをチェックして、使用不可能なマニューバを非活性化（グレーアウト）する役割も担います。戦闘中に人形設計図を開く「🪪」ボタンもここで生成されます。 |
| `showCharacterSheetModal()` | アンデッドの「詳細」ボタンが押されたときに、キャラクターの全情報（パーソナルデータ、スキル、パーツなど）を整形して、人形設計図モーダルとして表示します。画像の変更ボタンや初期配置の選択リストもここで生成・制御しています。 |
| `showUndeadListModal()` | 「アンデッドを追加」カードがクリックされたときに、`undead.json`から取得したテンプレート一覧をモーダルで表示します。キャラクターの種別フィルタリングや、「保管所から読込み」ボタンの設置もここで行います。 |
| `showImportCharacterModal()` | 「保管所から読込み」ボタンが押されたときに、キャラクターシートIDを入力するためのモーダルを表示します。入力されたIDを元に`fetchVampireBloodSheet`を呼び出し、一連のインポート処理を管理します。 |
| `fetchVampireBloodSheet()` | キャラクターシート保管所のサーバーにJSONPリクエストを送信し、キャラクターデータを非同期で取得する専門の関数です。 |
| `buildMoveMenu()` | 移動マニューバが選択された際に、移動可能なエリアを計算し、エリアカラーで色分けされたボタンを持つ専用のメニューをモーダルで表示します。「逃走」ボタンの表示と活性/非活性の制御もここで行います。 |
| `showImageSelectionModal()` | 人形設計図の「✏️ 画像の変更」ボタンが押されたときに、`images`フォルダ内の画像一覧をモーダルで表示し、選択された画像にキャラクターデータを更新する機能を提供します。 |

#### 3. ユーザー操作の処理（イベントハンドラ）

右側パネルの宣言リストなど、特定のUI要素がクリックされたときに直接呼び出され、`battle-logic.js`に処理を依頼する関数群です。

| 関数名 | 機能概要 |
| :--- | :--- |
| `handleActionItemClick()` | アクション宣言リストの項目がクリックされたときに呼び出され、`battleLogic.resolveActionByIndex()`を呼び出します。 |
| `handleJudgeItemClick()` | ジャッジ宣言リストの項目がクリックされたときに呼び出され、`battleLogic.checkJudgeItem()`を呼び出して、その項目を「解決済み」にします。 |
| `handleQueueCheck()` | ラピッド宣言リストのチェックボックスが変更されたときに呼び出され、`battleLogic.handleQueueCheck()`に状態を伝達します。 |
| `handleDamageItemClick()` | ダメージ処理リストの項目がクリックされたときに呼び出され、`showDamageModal`（パーツ損傷モーダル）を開くか、`battleLogic.applyDamage()`を直接呼び出します。 |

#### 4. 内部ヘルパー関数

上記の主要な関数群を補助するための、内部的な計算やチェックを行う関数です。

| 関数名 | 機能概要 |
| :--- | :--- |
| `checkTargetAvailability()` | あるマニューバが、射程内に有効な**キャラクターターゲット**を持つかどうかを判定します。（主に攻撃や移動マニューバ用） |
| `getTargetableDeclarations()` | あるジャッジマニューバが、射程内に有効な**アクション宣言ターゲット**を持つかどうかを判定します。（主に支援・妨害マニューバ用） |
| `closeAllMenus()` | 表示されている全てのポップアップメニュー（マニューバメニューなど）を閉じます。 |
| `handleGlobalClick()` | 画面のどこかがクリックされたかを監視し、メニュー外がクリックされた場合はメニューを閉じる、ターゲット選択中に選択対象外がクリックされた場合は選択をキャンセルする、といったグローバルな制御を行います。 |

---

「処理を単純化して、堅牢性を高めたい」という方針、そしてそのための具体的なアプローチ、どちらも非常に素晴らしいです。アプリケーションの安定性と保守性を劇的に向上させるための、まさに理想的な考え方です。

**「ユーザー操作 → 状態変更処理 → 描画に必要な情報の最終チェック → 描画」**
という一方向のデータフローを徹底すること、そして
**「ロジック側で可否を厳密に判定し、UI側はそれを表示するだけ（マスクするだけ）」**
という責務の分離は、複雑なアプリケーションを堅牢に保つための鍵となります。

その方針は、私が前回ご提案した**「監視者アーキテクチャ」**の考え方と完全に一致します。改めて、このアーキテクチャにおける各モジュールの役割を整理させてください。

### 理想的な処理フロー（監視者アーキテクチャ）

ユーザーの操作が発生した後の流れは、以下のようになります。

```mermaid
graph TD
    A[ユーザー操作<br>(例: アクション宣言をクリック)] --> B(<b>interaction-manager.js</b><br>「このアクションを解決して」と依頼);
    B --> C(<b>battle-logic.js</b><br>依頼された処理を実行し、<br>戦闘状態(battleState)を更新);
    C --> D{<b>determineNextStep()</b><br><b>(監視者)</b>};
    D --> E[<b>状態の厳密なチェック</b><br>・次に行動できるのは誰か？<br>・アクティブなタイミングは？<br>・未解決の処理は残っているか？<br>などを<u>battleStateから再計算</u>];
    E --> F(<b>ui-manager.js</b><br>「この最新情報で画面全体を再描画せよ」<br>と一度だけ命令);
    F --> G[UIの完全な再描画<br>(カード、マーカー、各種パネルなど)];
```

このフローの最大の利点は、**UIの更新命令が常に監視者(`determineNextStep`)から一度だけ発行される**ことです。これにより、処理の途中で中途半端な状態でUIが描画されることがなくなり、更新漏れも防げます。

### マニューバリストのマスク処理について

「マニューバデータに書かれている条件を満たさなければマスクする」という方針も、全くその通りです。これを実現するのが、`menu-builder.js`の`getCharacterManeuvers`関数の役割です。

この関数は、まさに**「描画に必要なフラグなどを厳密に確認する」**処理の中核を担います。

1.  **入力**: キャラクター情報と、監視者が管理する`battleState`（戦闘の最新状態）を受け取ります。
2.  **判定**: `battleState`を元に、キャラクターが持つ各マニューバについて、以下の条件を**すべてチェック**します。
    *   **タイミング**: 今はそのマニューバを使えるタイミングか？（アクション、ラピッド、ジャッジ…）
    *   **コスト**: 行動値は足りているか？
    *   **使用回数**: ターン1回の制限に達していないか？
    *   **パーツの状態**: 損傷していないか？
    *   **対象の有無**: 射程内に有効なターゲットは存在するか？
    *   **その他の特殊条件**: （例：「ダメージを受けている時のみ」など）
3.  **出力**: すべての条件をクリアしたマニューバには `isUsable: true`、一つでも満たさなければ `isUsable: false` という**「フラグ」**を付けて、マニューバのリストを返します。

そして、UIを描画する側の`createManeuverItem`関数は、この`isUsable`フラグだけを見て、`true`ならクリック可能にし、`false`なら`is-masked`クラスを付与して非活性化（マスク）します。

この仕組みにより、**複雑な使用可否の判断はすべて`getCharacterManeuvers`に集約**され、UI側は判定結果に従うだけ、という非常にクリーンで堅牢な構造が実現できます。